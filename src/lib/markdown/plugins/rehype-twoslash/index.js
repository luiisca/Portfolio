/**
 * @import {Grammar} from '@wooorm/starry-night'
 * @import {ElementContent, Root} from 'hast'
 * @import {} from 'mdast-util-to-hast' // Augmentation.
 * @import {TwoslashNode} from 'twoslash'
 * @import {VFile} from 'vfile'
 * @import {State, Options} from './types.js'
 */

import { createStarryNight } from '@wooorm/starry-night';
import sourceJson from '@wooorm/starry-night/source.json';
import sourceJs from '@wooorm/starry-night/source.js';
import sourceTsx from '@wooorm/starry-night/source.tsx';
import sourceTs from '@wooorm/starry-night/source.ts';
import { toString } from 'hast-util-to-string';
import { createTwoslasher } from 'twoslash';
import { SKIP, visitParents } from 'unist-util-visit-parents';
import { ok as assert } from 'devlop';
import { annotate } from './annotate.js';
import { smallShingleHash } from './shingle.js';
import { toHtml } from 'hast-util-to-html';
import {
	completion as defaultCompletion,
	error as defaultError,
	highlight as defaultHighlight,
	hover as defaultHover,
	query as defaultQuery
} from './render.js';

/** @type {Readonly<Options>} */
const defaultOptions = {};

/**
 * Default grammars.
 *
 * @type {ReadonlyArray<Readonly<Grammar>>}
 */
// @ts-expect-error: `source.json` is incorrectly seen by TypeScript as JSON.
const defaultGrammars = [sourceJson, sourceJs, sourceTsx, sourceTs];

/**
 * Map files generated by the TS compiler to `starry-night` scopes.
 */
const extensionToScopeMap = new Map([
	['json', 'source.json'],
	['js', 'source.js'],
	['tsx', 'source.tsx'],
	['ts', 'source.ts']
]);

/**
 * Prefix for language classes.
 */
const prefix = 'language-';

/**
 * escape curlies, backtick, \t, \r, \n to avoid breaking output of {@html `here`} in .svelte
 *
 * @param {string} str
 */
export const escape_svelty = (str) =>
	str
		.replace(
			/[{}`]/g,
			//@ts-ignore
			(c) => ({ '{': '&#123;', '}': '&#125;', '`': '&#96;' })[c]
		)
		.replace(/\\([trn])/g, '&#92;$1');

/**
 * Plugin to process JavaScript and TypeScript code with `twoslash`
 * and highlight it with `starry-night`.
 *
 * @param {Readonly<Options> | null | undefined} [options]
 *   Configuration (optional).
 * @returns
 *   Transform.
 */
export default function rehypeTwoslash(options) {
	const settings = options || defaultOptions;
	const starrySettings = settings.starry || {};
	const renderers = settings.renderers || {};
	const directive = typeof settings.directive === 'boolean' ? settings.directive : true;
	const idPrefix = settings.idPrefix || 'rehype-twoslash-';
	const starryNightPromise = createStarryNight(
		settings.grammars || defaultGrammars,
		starrySettings
	);
	const twoslash = createTwoslasher(settings.twoslash || undefined);

	/**
	 * Transform.
	 *
	 * @param {Root} tree
	 *   Tree.
	 * @param {VFile} file
	 *   File.
	 * @returns {Promise<Root>}
	 *   Given tree.
	 */
	return async function (tree, file) {
		const starryNight = await starryNightPromise;
		/** @type {Map<string, number>} */
		const hashToCount = new Map();

		// work on a pre node, and replace it with its code block processed with twoslash and starry night
		visitParents(tree, 'element', function (node, parents) {
			// get inmediate parent
			const parent = parents.at(-1);
			/* c8 ignore next - element at root never happens with `unified`; only if you do it manually. */
			// pre element index
			const index = parent ? parent.children.indexOf(node) : undefined;

			if (!parent || index === undefined || node.tagName !== 'pre') {
				return;
			}

			// node is a pre element
			const head = node.children[0];

			if (!head || head.type !== 'element' || head.tagName !== 'code') {
				return SKIP;
			}

			// head is a <code /> element
			const classes = head.properties.className;

			if (!Array.isArray(classes)) return;

			// checking if code block should be processed with twoslash
			const meta = head.data?.meta || '';
			const directiveTwoslash = classes.includes('twoslash') || meta.startsWith('twoslash');
			const directiveNoTwoslash = classes.includes('no-twoslash') || meta.startsWith('no-twoslash');

			if (classes.includes('notwoslash')) {
				file.message('Unexpected `notwoslash` class, expected `no-twoslash`', {
					ancestors: [...parents, node],
					place: node.position,
					ruleId: 'missing-dash-class',
					source: 'rehype-twoslash'
				});
			}

			if (meta.startsWith('notwoslash')) {
				file.message('Unexpected `notwoslash` directive, expected `no-twoslash`', {
					ancestors: [...parents, node],
					place: node.position,
					ruleId: 'missing-dash-directive',
					source: 'rehype-twoslash'
				});
			}

			if (directiveNoTwoslash || (directive && !directiveTwoslash)) return;

			const language = /** @type {string | undefined} */ (
				classes.find(function (c) {
					return typeof c === 'string' && c.startsWith(prefix);
				})
			);

			let scope = language ? starryNight.flagToScope(language.slice(prefix.length)) : undefined;

			// ensure we highlight only js and ts blocks
			// TODO: add support for other languages
			if (scope !== 'source.js' && scope !== 'source.ts' && scope !== 'source.tsx') {
				if (directiveTwoslash) {
					file.message(
						'Unexpected non-js/ts code' +
							(scope ? ' (`' + scope + '`)' : '') +
							' with twoslash directive, expected JavaScript or TypeScript code',
						{
							ancestors: [...parents, node],
							place: node.position,
							ruleId: 'non-js-ts-with-twoslash',
							source: 'rehype-twoslash'
						}
					);
				}

				return SKIP;
			}

			let value = toString(head);
			/** @type {State} */
			const state = {
				count: -1,
				idPrefix: idPrefix + smallShingleHash(value, hashToCount) + '-',
				renderers: {
					completion: renderers.completion || defaultCompletion,
					error: renderers.error || defaultError,
					highlight: renderers.highlight || defaultHighlight,
					hover: renderers.hover || defaultHover,
					query: renderers.query || defaultQuery
				},
				starryNight
			};
			/** @type {Array<TwoslashNode>} */
			let annotations = [];

			try {
				// process code block with twoslash
				// console.log('üíª code element', value, scope);
				const result = twoslash(
					value,
					scope === 'source.js' ? 'js' : scope === 'source.tsx' ? 'tsx' : 'ts'
				);
				// console.log('ü§Ø twoslash result', result);
				value = result.code;
				annotations = result.nodes;
				scope = extensionToScopeMap.get(result.meta.extension);
			} catch (error) {
				console.warn('‚ùå twoslash error', error);
				const cause = /** @type {Error} */ (error);
				file.message('Unexpected error running twoslash', {
					ancestors: [...parents, node],
					cause,
					place: node.position,
					ruleId: 'twoslash',
					source: 'rehype-twoslash'
				});
			}

			assert(scope);

			// highlight twoslash-processed code block with starry night
			const fragment = starryNight.highlight(value, scope);
			/** @type {Array<ElementContent>} */
			const footer = [];
			/** @type {TwoslashNode | undefined} */
			let previous;

			for (const annotation of annotations) {
				let skip = false;

				// Tags are zero length, so not sure how to render them.
				if (annotation.type === 'tag') {
					skip = true;
				}

				// Drop the `hover`, which is likely `any` or at least presumably irrelevant,
				// when a completion follows.
				// For example:
				// ```ts
				// console.e
				//          ^|
				// ```
				// There would be a hover of `any` on the `e` and a completion right
				// after it, which is likely relevant.
				if (
					previous &&
					previous.type === 'completion' &&
					annotation.type === 'hover' &&
					previous.length === 0 &&
					previous.start >= annotation.start &&
					previous.start <= annotation.start + annotation.length
				) {
					skip = true;
				}

				if (!skip) footer.push(...annotate(fragment, annotation, state));

				previous = annotation;
			}

			const langname = scope.replace(/^source\./, '').replace(/\./g, '-');

			// update code block classes
			head.properties.className = [
				// With the output language class.
				'language-' + langname,
				// Without the input language class:
				...classes.filter((d) => d !== language)
			];

			// replac the pre element with new twoslash and starry night processed one
			parent.children.splice(index, 1, {
				type: 'element',
				tagName: 'div',
				properties: { className: ['highlight', 'highlight-' + langname] },
				children: [
					{ type: 'text', value: '\n' },
					{
						// The `<pre>` node.
						...node,
						children: [
							{
								// The `<code>`.
								...head,
								children: [
									{
										type: 'raw',
										value: `{@html \`${escape_svelty(toHtml(fragment.children))}\`}`
									}
								]
							}
						]
					},
					...footer.map((f) => {
						// console.log('ü§Ø footer element', f);
						// f.children?.forEach((c) => console.log('ü§Ø footer child', c));
						// console.log('to html', toHtml(f));

						// console.log('raw', { type: 'raw', value: `{@html \`${escape_svelty(toHtml(f))}\`}` });
						if (f.value === '\n') {
							return f;
						}

						return {
							type: 'raw',
							value: `{@html \`${escape_svelty(toHtml(f))}\`}`
						};
					}),
					{ type: 'text', value: '\n' }
				]
			});

			return SKIP;
		});

		// Note: `Promise<undefined>` or `Promise<void>` as return type seem to fail
		// `unified`‚Äôs types.
		return tree;
	};
}
